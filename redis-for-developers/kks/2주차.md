# 레디스를 캐시로 사용하기

## 캐싱 전략

- 읽기 전략 - look aside
    - 레디스에서 데이터를 먼저 조회하고 캐시 미스가 발생 했을 때 원본 데이터베이스에 접근하여 데이터를 조회하는 방식
    - 레디스 장애 발생 시 원본 데이터베이스에 커넥션이 몰리면서 부하가 발생할 수 있음
    - 사용 중인 서비스에 처음 레디스를 도입하거나 새로운 데이터를 데이터베이스에만 추가할 경우 데이터를 조회하기 위해 레디스와 데이터베이스를 모두 접근하여 응답 지연이 발생할 수 있음
    - 이를 방지하려면 데이터를 미리 데이터베이스에서 캐시로 밀어 넣는 캐시 워밍 작업이 필요할 수 있음
- 쓰기 전략과 캐시의 일관성
    - write through
        - 캐시에 먼저 데이터를 업데이트하고 원본 데이터베이스를 업데이트
    - cache invalidation
        - 데이터베이스를 업데이트하면서 캐시를 삭제
    - write behind
        - 캐시를 업데이트하고 비동기로 원본 데이터베이스를 업데이

## 메모리 관리

레디스에서는 데이터의 최대 저장 용량을 설정하는 `maxmemory` 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 `maxmemory-policy` 설정값을 사용해 매모리를 관리한다.

### maxmemory-policy

#### Noeviction

데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 에러를 반환하는 설정 값으로 레디스 기본 설정 값이다. 관리자가 직접 데이터를 관리해야하기 때문에 레디스를 캐시로 사용할 때 권장하지 않는 설정 값이다.

#### LRU(Least-Recently Used) eviction

레디스에 데이터가 가득 찼을 때 가장 최근에 사용 되지 않은 데이터부터 삭제하는 정책이다.

- `volatile-lru`
  - 만료 시간이 설정돼 있는 키만 LRU 방식으로 삭제함
  - 모든 키가 만료시간이 저장되어 있지 않을 경우 Noeviction 방식과 동일하게 장애가 발생할 수 있으므로 주의해야함
- `allkeys-lru`
  - 모든 키를 LRU 방식으로 삭제함

#### LFU(Least-Frequently Used) eviction

레디스에 데이터가 가득 찼을 때 가장 자주 사용되지 않은 데이터를 삭제하는 정책으로 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다는 특징이 있다. 키가 오랫동안 사용되지 않았더라도 과거에 자주 액세스했던 키라면 나중에도 자주 사용될 수 있다는 가정하에 우선순위를 높게 계산한다.

- `volatile-lfu` : 만료 시간이 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제
- `allkeys-lfu` : 모든 키에 대해 LFU 알고리즘을 이용해 데이터를 삭제함

#### Random eviction

- 저장된 키 중 하나를 임의로 골라내 삭제한다.
- 삭제될 키 값을 계산하지 않아도 된다는 점에서 레디스의 부하를 줄여줄 수 있는 방법이다.

#### volatile-ttl

만료 시간이 가장 작은 키를 삭제한다. LRU, LFU와 마찬가지로 근사 알고리즘을 사용하기 때문에 저장된 모든 키를 스캔하면서 만료 시간을 비교하지 않는다.