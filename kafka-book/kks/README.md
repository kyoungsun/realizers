### 카프카를 구성하는 주요 요소

* 주키퍼(ZooKeeper) : 카프카의 정상 동작을 보장하기 위해 메타데이터를 관리하는 코디네이터
    * 최신 버전에서는 주키퍼 의존성을 제거하는 방향으로 발전하고 있음
    * 아직 운영 환경에서 사용하기에는 무리가 있음
* 카프카(Kafka) 또는 카프카 클러스터(Kafka cluster) : 아파치 프로젝트 애플리케이션 이름으로 여러 대의 브로커를 구성한 클러스터를 의미함
* 브로커(broker) : 카프카 애플리케이션이 설치된 서버 또는 노드를 말함
* 프로듀서(producer) : 카프카로 메시지를 보내는 역할을 하는 클라이언트를 총칭함
* 컨슈머(consumer) : 카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트를 총칭함
* 토픽(topic) : 카프카는 메시지 피드들을 토픽으로 구분함, 각 토픽의 이름은 카프카 내에서 고유함
* 파티션(partition) : 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말함
* 세그먼트(segment) : 프로듀서가 전송한 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일을 말함
* 메시지(message) 또는 레코드(record) : 프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각을 말함

### 리플리케이션

리플리케이션(replication)이란 각 메시지들을 여러 개로 복제해서 카프카 클러스터 내 브로커들에 분산시키는 동작을 의미함

#### 효율적인 리플리케이션 팩터 수 설정

* 테스트나 개발 환경 : 리플리케이션 팩터 수를 1로 설정
* 운영 환경(로그성 메시지로서 약간의 유실 허용) : 리플리케이션 팩터 수를 2로 설정
* 운영 환경(유실 허용 X) : 리플리케이션 팩터 수를 3으로 설정
    * 안정성을 높히기 위해 리플리케이션 펙터 수를 더 올릴 수 있지만 3으로도 충분히 메시지 안정성을 보장하고 적절한 디스크 공간 사용이 가능함

#### 리더와 팔로워

* 리더는 리플리케이션 중 하나가 선정되며, 모든 읽기와 쓰기는 리더를 통해서만 가능함
* 리더와 팔로워는 ISR이라는 논리적 그룹으로 묶여 있음
  * 해당 그룹 안에 속한 팔로워들만 리더에 장애가 발생했을 때 새로운 리더의 자격을 가질 수 있음
  * 리더가 읽고 쓰는 동작과 팔로워가 리플리케이션 동작을 잘 수행하고 있는지 판단
  * ISR 내의 팔로워들은 리더와 데이터 일치를 위헤 지속적으로 데이터 복제 요청을 보냄
  * 팔로워가 특정 주기의 시간만큼 복제 요청을 하지 않는다면 리더는 해당 팔로워를 ISR 그룹에서 추방
  * ISR 내에서 모든 팔로워의 복제가 완료되면, 리더는 내부적으로 커밋되었다는 표시를 함
  * 마지막 커밋 오프셋 위치는 하이워터마크(high water mark)라고 부름
    * 컨슈머는 커밋된 메시지만 읽어갈 수 있음
  * 커밋된 메시지를 유지하기 위해 로컬 디스크의 replication-offset-checkpoint라는 파일에 마지막 커밋 오프셋 위치를 저장함
* 리더와 팔로워 간의 리플리케이션 동작을 처리할 때 서로의 통신을 최소화할 수 있도록 설계함으로써 리더의 부하를 줄임
  * 리더는 팔로워들이 리플리케이션 동작이 성공했다는 ACK를 받지 않음
  * 팔로워는 리더에 메시지 가져오기(fetch) 요청을 보내는데 리플리케이션 성공한 오프셋을 같이 보냄
  * 리더는 팔로워가 보낸 요청의 오프셋 위치를 확인하고 어디까지 리플리케이션이 성공했는지 파악하는 구조
  * 다음 오프셋 메시지에 대한 리플리케이션 요청에 대한 응답에 이전 오프셋 메시지가 커밋되었다는 내용도 함께 전달함
  * 리플리케이션 동작 방식도 팔로워들이 풀(pull)하는 방식으로 동작하여 리더의 부하를 줄임
* 리더에포크(LeaderEpoch)를 이용하여 카프카의 파티션들이 복구 동작을 할 때 메시지의 일관성을 유지함

### 컨트롤러

* 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하며, 파티션의 ISR 리스트 중에서 리더를 선출함
* 리더를 선출하기 위한 ISR 리스트 정보는 가용성 보장을 위해 주키퍼에 저장함

### 세그먼트

* 프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장되고, 각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장됨
* 메시지의 키, 벨류, 오프셋, 메시지 크기 같은 정보가 함께 보관됨

### 파티션

하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 토픽 하나를 여러 개로 나눠 병렬 처리가 가능하게 만든 것을 파티션이라고 함

* 파티션 수만큼 컨슈머를 연결하여 사용할 수 있음
* 파티션 번호는 0부터 시작함
* 파티션 수는 토픽을 생성할 때 욥션으로 설정함
    * 파티션 수를 정하는 기준은 메시지 크기나 초당 메시지 건수 등에 따라 달라지므로 정확하게 예측하기는 어려움
    * **한 번 늘린 파티션 수는 절대로 줄일 수 없음**
    * 최초 파티션을 작게 생성하고 모니터링을 통해 조금씩 늘려가는 방법이 가장 좋음

### 카프카가 높은 처리량과 안정성을 지니게 된 특성들

* 분산 시스템
    * 네트워트상에서 연결된 컴퓨터 그룹으로 구성됨
    * 카프카 클러스터는 브로커를 운영 중인 상태에서도 쉽게 브로커를 확장할 수 있음
* 페이지 캐시
    * 직접 디스크에 읽고 쓰는 대신 물리 메모리 중 애플리케이션이 사용하지 않는 일부 잔여 메모리를 활용함
    * 페이지 캐시 사용 시 디크스 I/O에 대한 접근이 줄어들어 성능을 높힐 수 있음
* 배치 전송 처리
    * 프로듀서, 컨슈머, 클라이언트들에서 발생하는 수많은 통신을 묶어서 처리함
* 압축 전송
    * gzip, snappy, lz4, zstd 등의 압축 타입을 지원함
    * 높은 압축률 : gzip, zstd
    * 빠른 응답 속도 : lz4, snappy
* 토픽, 파티션, 오프셋
    * 파티션마다 순처적으로 증가하는 숫자
    * 파티션에서의 오프셋은 고유한 숫자로, 카프카에서는 오프셋을 통해 메시지의 순서를 보장하고 컨슈머에서는 마지막까지 읽은 위치를 알 수 있음
* 고가용성 보장
    * 분산 시스템으로 하나의 서버나 노드가 다운되어도 다른 서버가 역할을 대신함
    * 리플리케이션 기능을 제공함
        * 리더는 프로듀서, 컨슈머로부터 오는 모든 읽기와 쓰기 요청을 처리
        * 팔로워는 오직 리더로부터 리플리케이션함
* 주키퍼
    * 여러 대의 서버를 클러스터로 구성하여 과반수 이상의 노드가 유지되면 지속적인 서비스가 가능한 구조
    * 카프카가 성장하면서 주키퍼 성능의 한계가 드러나기 시작함, 주키퍼에 대한 의존성을 제거하기 위한 개발이 진행중임
