# 07장-가치 있는 단위 테스트를 위한 리팩터링

- 네 가지 코드 유형
- 험블 객체 패턴 이해
- 가치있는 테스트 작성

## 7. 1. 리팩터링할 코드 식별하기

코드 복잡도 및 도메인 유의성, 협력자 수로 네가지 코드 유형을 분류할 수 있다.

### 7.1.1 코드의 네 가지 유형

1. 도메인 모델 및 알고리즘 : 복잡도 및 도메인 유의성⬆️, 협력자 수⬇️
2. 간단한 코드 : 복잡도 및 도메인 유의성⬇️, 협력자 수 ⬇️
3. 컨트롤러 : 복잡도 및 도메인 유의성⬇️, 협력자 수⬆️
4. 지나치게 복잡한 코드 : 복잡도 및 도메인 유의성⬆️, 협력자 수⬇️

- 도메인 모델 및 알고리즘을 단위 테스트하면 노력 대비 가장 이롭다.(최소비용 최대효과)
- 간단한 코드는 테스트 가치가 0 → 통합 테스트로 해결가능
- 가장 곤란한 경우가 지나치게 복잡한 코드 → 테스트가 필요하나, 공간 및 비용이 많이 든다.
- 코드가 중요해지거나 복잡해질 수록 협력자는 더 적어야 한다.
- 이상적으로는 지나치게 복잡한 코드는 존재하면 안된다.
- 지나치게 복잡한 코드는 협력자 수를 줄여서 도메인 모델 및 알고리즘의 구역 또는 컨트롤러 영역으로 갈 수 있도록 리팩토링 해야한다.

### 7.1.2 험블 객채 패턴을 사용해 지나치게 복잡한 코드 분할 하기

- 지나치게 복잡한 코드는 어려운 의존성과 로직을 함께 가지고 있다.
- 험블 객체 패턴은 코드에서 로직을 추출해 코드를 테스트할 필요없도록 간단하게 만든후 어려운 의존성에서 분리된 다른 클래스로 이동시킨다.
- 육각형 아키텍쳐는 비즈니스 로직과 프로세스 외부 의존성(테스트하기 어려운 의존성)과의 통신을 분리한다.
- 함수형 아키텍쳐는 더 나아가 모든 협력자와의 커뮤니케이션에서 비즈니스 로직을 분리한다.
- 함수형 코어에는 아무런 협력자가 없다.
- 비즈니스 로직과 오케스트레이션을 분리

## 7.2 가치 있는 단위 테스트를 위한 리팩터링 하기

### 7.2.1 고객 관리 시스템 소개

- 모든 사용자는 데이터베이스에 저장된다.
- 사용자는 이메일 변경이 가능하다.
- 사용자 이메일이 회사 도메인인 경우 직원으로 표시 그외는 고객으로 표시
- 직원의 수가 추적되야한다. 사용자 유형이 변경된 경우 이 숫자도 변경되야한다.
- 이메일이 변경되면 메세지 버스로 메시지를 보내야한다.

### 7.2.2 1단계 : 암시적 의존성을 명시적으로 만들기

- 프로세스 외부 협력자 및 라이브러리를 암시적 의존성으로 분류
- 예시로 데이터베이스, 메시지 버스
- 도메인 모델은 외부 시스템과의 통신을 책임지지 않아야한다.

### 7.2.3 2단계 : 애플리케이션 서비스 계층 도입

- 외부 시스템과 통신할 수 있는 애플리케이션 서비스 필요
- 도메인 클래스는 다른 도메인 클래스나 단순 값과 같은 프로세스 내부 의존성에만 의존

### 7.2.4 3단계 : 애플리케이션 서비스 복잡도 낮추기

- 재구성 로직을 추출
- 도메인 클래스를 인스턴스화 하는 팩토리 클래스 만들기
- 재구성 로직은 도메인 유의성이 없다. (클라이언트의 목표과 관련 X)

### 7.2.5 4단계 : 새 Company 클래스 소개

## 7.3 최적의 단위 테스트 커버리지 분석

- 전제 조건을 테스트 해야하는가?
    - 도메인 유의성이 있는 모든 전제 조건은 테스트를 진행한다.

## 7.4 컨트롤러에서 조건부 로직 처리

- 비즈니스 연산이 복잡한 경우
- 비지니스 연산 중에 프로세스 외부 의존성을 계속 참조해야하는 경우
- 도메인 모델 테스트 유의성, 컨트롤러 단순성, 성능의 균형 맞추기
- 세가지 특성을 모두 충족하는 해법은 없다.
- 의사결정 프로세스 단계를 세분화 하기

### 7.4.1 CanExecute/Execute

- 컨트롤러에서 의사결정을 제외한다.
- 유효성검사는 컨트롤러로부터 캡슐화 해야한다.

### 7.4.2 도메인 이벤트를 사용해 도메안 모델 변경 사항 추적

## 7.5 결론

- 외부 시스템에 대한 애플리케이션의 사이드 이펙트를 추상화
- 컨트롤러에 비지니스로직을 아예 없앨 수 없는 경우 O
- 도메인 클래스에서 모든 협력자를 제거할 수 없는 경우 O
- 도메인 클래스에서 중요한 것은 프로세스 외부 의존성을 참조하면 X
- 결국 식별할 수 있는 동작과 구현 세부사항을 계층에 맞게 잘 구분해야한다.
- 계층에 따라 구현 세부사항 이었던 것이 식별할 수 있는 동작이 되기도 한다.