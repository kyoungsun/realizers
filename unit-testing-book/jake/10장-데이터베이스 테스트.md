10장 데이터베이스 테스트

**데이터베이스 테스트를 위한 전제 조건**

- 형상 관리 시스템에 데이터베이스 유지
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
- 데이터베이스 배포에 마이그레이션 기반 방식 적용

**데이터베이스를 형상 관리 시스템에 유지**

- 데이터베이스 스키마를 일반 코드로 취급하는것 (일반코드처럼 형상관리)

모델 데이터베이스를 사용하는 것은 데이터베이스 스키마를 유지하는 데 상당히 좋지 못한 방법이다.

- 변경내역부재 : 데이터베이스 스키마를 과거의 특정 시점으로 되돌릴 수 없다.
- 복수의 원천 정보 : 모델 데이터베이스는 개발 상태에 대한 원천 정보를 둘러싸고 경합하게 된다.

**참조 데이터도 데이터베이스 스키마다**

참조 데이터는 애플리케이션의 필수 사항이므로, 테이블, 뷰 그리고 다른 데이터베이스 스키마와 함께 SQL INSERT 문 형태로 형상 관리 시스템에 저장해야 한다.

**테스트 실행 속도를 극대화하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용하라.**

**상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포**

**상태 기반 방식**

- 배포 중에 비교 도구가 스크립트를 생성해서 운영데이터베이스를 모델 데이터베이스와 비교해 최신상태를 유지한다.
- 차이점은 상태 기반방식을 사용하면 물리적인 모델 데이터베이스는 원천 데이터가 아니라는것. 대신 해당 데이터 베이스를 작성하는 데 사용할 수 있는 SQL 스크립트가 있다. 스크립트는 형상관리에 저장됨

**마이그레이션 방식**

- 데이터베이스를 어떤 버전에서 다른 버전으로 전환하는 명시적인 마이그레이션을 의미
- 운영 데이터베이스와 개발 데이터베이스를 자동으로 동기화하는 도구는 쓸수없고, 업그리에드 스크립트를 직접 장성해야한다.

**상태 기반 방식보다 마이그레이션 기반 방식을 선호하라.**

- 상태 기반 방식은 상태를 형상 관리에 저장함으로써 상태를 명시하고 비교 도구가 마이그레이션을 암묵적으로 데어할 수 있게 한다.
- 마이그레이션 기반 방식은 마이그레이션을 명시적으로 하지만 상태를 암묵적으로 둔다. 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다.

**데이터베이스 트랜잭션에서 데이터베이스 연결 분리**

- 업데이트할 데이터
- 업데이트 유지 또는 롤백 여부

컨트롤러가 이러한 결정을 도시에 내릴 수 없으므로 이렇게 분리하는 것이 중요하며 비즈니스 연산의 모든 단계가 성공했을 때 업데이트를 수행할 수 있는지 여부만 안다. 또한 데이터베이스에 접근하고 업데이트를 시도해야만 이러한 단계를 밟을 수 있다. Database 클래스를 리포지터리와 트렌잭션으로 나눠서 이러한 책임을 구분할 수 있다.

**작업단위로 업그래이드 하기**

일반 트랜잭션과 비교해서 작업 단위가 갖는 가장 큰 장점은 업데이트 지연이다. 트랜잭션과 달리 작업 단위는 비즈니스 연산 종료 시점에 모든 업데이트를  실행하므로 데이터베이스 트랜잭션의 기간을 단축하고 데이터 혼잡을 줄인다.

통합 테스트에서 데이터베이스 트랜잭션을 관리하는 경우 다름 지침을 준수하라.

- 테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말자.
- 통합테스트에서 적어도 세 개의 트랜잭션 도는 작업 단위를 사용하라(준비, 실행, 검증) 구절당 하나씩

테스트 데이터 생명 주기

- 통합 테스트를 순차적으로 실행하라.
- 테스트 실행 간에 남은 데이터를 제거하라.

통합 테스트의 실행 시간을 최소화해야 하는 경우가 아니라면 컨테이너를 사용하지 않는 것이 좋다. 데이터베이스는 개발자당 하나의 인스턴스만 갖는 것이 더 실용적이다.

인메모리 데이터베이스는 일반 데이터베이스와 기능적으로 일관성이 없기 때문에 사용하지 않는 것이 좋다.

- 환경과 일치하지 않는 문제
- 거짓 양성 또는 거짓 음성 발생 할 경우가 높음

필수가 아닌 부분을 비공개 메서드 또는 헬퍼 클래스로 추출해 테스트를 단축하라.

- 준비구절에서는 테스트 데이터 빌더 대신 오브젝트 마더를 선택하라.
- 실행구절에서는 데코레이터 메서드를 작성하라.
- 검증 구절에서는 플루언트 인터페이스를 도입하라.

읽기 테스트는 임계치는 쓰기 테스트 임계치보다 높아야 한다. 가장 복잡하거나 중요한 읽기 작업만 테스트 하라.

리포지터리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트로 취급하라. 리포지터리 테스트는 회귀 방지에 대한 이득이 너무 적은 데 반해 유지비용이 높다.