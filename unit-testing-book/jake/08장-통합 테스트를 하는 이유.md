#8장 통합 테스트를 하는 이유


통합합테스트의 역할

- 단일  동작 단위를 검증
- 빠르게 수행
- 다른 테스트와의 별도처리

단위테스트의 요구사항 중 **세가지 요구사항 중 하나라도 충족하지 못하면 통합테스트에 속한다.**

프로세스 외부 의존성을 목으로 대체한다면 컨트롤러 사분면을 단위 테스트로 처리할 수 있다. 그러나 대부분의 애플리케이션은 목으로 대체할 수 없는 프로세스 외부 의존성이 있다. 예로 들면 데이터베이스가 있다.

간단한 코드와 지나치게 복잡한 코드는 전혀 테스트해서는 안 된다. 간단한 코드는 노력을 들일 만한 가치가 없고, 복잡한 코드는 알고리즘과 컨트롤러로 리팩터링해야 한다.

통합테스트는 단위테스트에 비해 유지비용이 많이 든다. 반면 회귀 방지가 단위 테스트 보다 우수하여 리팩터링 내성도 우수하다.

통합테스트는 주요 흐름(happy path)과 단위 테스트가 다루지 못하는 기타 예외 상황(edge case)

**주요흐름은 시나리오의 성공적인 실행이다. 예외 상황은 비즈니스 시나리오 수행 중 오류가 발생하는 경우다.**

통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라.

모든 상호 작용을 거치는 흐름이 없으면, 외부시스템과의 통신을 모두 확인하는 데 필요한 만큼 통합 테스트를 추가로 작성하라.

좋지 않은 테스트를 작성하는 것보다는 테스트를 작성하지 않는 것이 좋다. 가치가 없는 테스트는 좋지 않은 테스트다.

빠른실패원칙 - 빠른 실패 원칙은 예기치 않은 오류가 발생하자 마자 현재 연산을 중단하는 것을 의미한다 빠른 실패를 통해 애플리케이션의 안정성을 높인다.

**프로세스 외부 의존성의 두가지 유형**

**관리 의존성 (전체를 제어할 수 있는 프로세스 외부 의존성)**

- 애플리케이션을 통해서만 접근할 수 있으며, 해당 의존성과의 상호 작용은 외부 환경에서 볼 수 없다. **대표적인 예로 데이터베이스**가 있다. 외부 시스템은 보통 데이터베이스에 직접 접근하지 아낳고 애플리케이션에서 제공하는 API를 통해 접근한다.
- **관리 의존성과 통신하는 것은 애플리케이션뿐이므로 하위 호환성을 유지할 필요가 없다 중요한것은 최종상태이다.**

**비관리 의존성 (전체를 제어할 수 없는 프로세스 외부 의존성)**

- 해당 의존성과의 상호 작용을 외부에서 볼 수있다. 예를 들어 SMTP 서버와 메시지 버스 등이 있다. 둘 다 다른 애플리케이션에서 볼 수 있는 사이드 이펙트를 발생시킨다.
- 비관리 의존성에 대한 통신 패턴을 유지해야 하는 것은 하위 호환성을 지켜야 하기 때문이다. 이러한 작업에는 목이 적합하며 목을 사용하면 모든 가능한 리팩터링을 고려해서 통신 패턴 영속성을 보장할 수 있다.

관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라.

**특이 케이스**

관리 의존성이면서 비관리 의존성인 프로세스

- 대표적인 예 다른애플리케이션이 접근할 수 있는 데이터베이스
- 시스템은 전용 데이터베이스로 시작하지만 다른시스템에서 같은 데이터베이스의 테이블을 공유할때 이런경우에는 비관리 의존성으로 취급하자. 테이블은 메세지 버스 역할을 하고, 각 행이 메시지 역할을 한다 이러한 테이블을 이용한 통신 패턴이 바뀌지 않도록 하려면 목을 사용하자.

통합 테스트에서 실제 데이터베이스를 사용 할 수 없는 경우

- 데이터베이스를 그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인모델의 단위 테스트에만 집중하자.

**엔드 투 엔드 테스트**

배포 후 프로젝트의 상태 점겅을 위해 한 개 또는 두개 정도의 중요한 엔드 투 엔드 테스트를 작성할 수 있다. 테스트가 가장 긴 주요 흐름을 거치게 해서 애플리케이션이 모든 프로세스 외부 의존성과 올바르게 통신할 수 있도록 한다. 외부 클라이언트의 동작을 모방하려면 메시지 버스는 직접 확인하고, 데이터베이스 상태는 애플리케이션을 통해 검증한다.

의존 추상화를 위한 인터페이스 사용

인터페이스의 사용이유

- 프로세스 외부 의존성을 추상화해 느슨한 결합을 유지하며
- 기존 코드를 변경하지 않고 새로운 기능을 추가해 공개 폐쇄 원칙(OCP)을 지킬수 있어서

단일 구현을 위한 인터페이스는 추상화가 아니다.

YAGNI(you aren’t gonna need it) 현재 필요하지 않은 기능에 시간을 들이지 말아라.

**프로세스 외부 의존성에 인터페이스를 사용하는 이유?**

목을 사용하기 위함이고 인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.

**의존성을 목으로 처리할 필요가 없는 한, 프로세스 외부 의존성에 대한 인터페이스를 두지 말라. 비관리 의존성만 목으로 처리하므로, 결국 비관리 의존성에 대해서만 인터페이스를 써야한다.**

**통합 테스트 모범 사례**

- 도메인 모델 경계 명시
- 애플리케이션 내 계층 줄이기
- 순환 의존성 제거하기

가능한 한 간접 계층을 적게사용하라. 대부분의 백엔드 시스템에서는 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층 이세가지만 활용하면 된다. 인프라 계층은 보통 도메인 모델에 속하지 않는 알고리즘과 프로세스 외부 의존성에 접근할 수 있는 코드로 구성한다.

테스트에 여러 실행 구절이 잇는 것은 올바른 상태가 되기 어려운 프로세스 외부의존성으로 작동하는 경우에만 타당하다. 단위 테스트는 프로세스 외부 의존성으로 수행되지 않기 떄문에 여러 가지 실행을 해서는 안 된다. 다단계 테스트는 대부분 엔드 투 엔드 테스트 범주에 속한다.

**로깅 테스트**

지원로깅은 지원부서나 시스템 관리자를 위한것이며, 애플리케이션의 식별할 수 있는 동작이다.

진당로깅은 개발자가 애플리케이션 내부에서 진행되는 작업을 이해하는데 조움을 주며, 구현세부사항이다.

지원로깅은 비즈니스 요구 사항이므로 해당 요구 사항을 코드베이스에 명시적으로 반영하다. 비즈니스에 필요한 모든 지원로깅이 나열돼 있는 특별한 DomainLogger클레스를 도입하라.

지원로깅을 프로세스 외부 의존성으로 작동하는 다른 기능처럼 취급하다. 도메인 이벤트를 사용해 도메인 모델의 변경 사항을 추적하라. 컨트롤러에서 도메인 이벤트를 DomainLogger 호출로 변환하라.

진단로깅은 테스트하지 말자. 지원로깅과 달리 도메인 모델에서 직접 진단 로그를 남길수도있다 또한 진단로깅을 너무 많이 쓰면 코드를 복잡하게 하고 로그의 신호 대비 잡을 비율이 나빠진다.