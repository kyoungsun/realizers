### 목과 스텁 구분

목은 상호 작용을 검사할 수 있는 테스트 대역이라고 했었다.

테스트 대역의 다른 유형이 바로 스텁(STUB)이다.

목(Mock)과 스텁(Stub)은 단위테스트에서 사용되는 테스트 대역(Test Double)의 두 가지 유형이다.

- ***목(Mock)**은 테스트 중에 다른 객체와의 상호작용을 검사하기 위해 사용**되며 목은 실제 객체의 동작을 모방하면서도 테스트 중에 발생하는 상호작용을 확인할 수 있기 때문에 테스트 대상 객체가 올바르게 동작하는지에 대한 검증을 진행하는데 유용.
- ***스텁(Stub)**은 테스트 중에 특정 메서드 호출에 대한 반환값을 지정하기 위해 모방하는데 사용된다.** 테스트 대상 객체가 다른 객체의 메서드를 호출할 때, 스텁은 실제 객체 대신하여 특정 호출에 대한 반환값을 정의한다. 이렇게 함으로써 테스트 중에 발생하는 상호작용의 결과를 조작하거나, 특정 시나리오에 따른 반환값을 테스트하기 위해 사용할 수 있다.

**정리하자면** 

목은 외부로 나가는 상호작용을 모방하고 검사하는데 도움이 된다.

스텁은 내부로 들어오는 상호 작용을 모방하는데 도움이 된다.

스텁과의 상호작용을 검증하면 취약한 테스트로 이어진다. 이러한 상호 작용은 최종 결과와는 일치하지 않으며 이는 결과로 가는 중간 단계로 봐야한다.

**명령 조회 분리(CQS)**

모든 메서드가 명령 또는 조회중 하나여야 하지만 둘 다는 안된다. 명령을 대체하는 테스트 대역은 목이다. 조회를 대체하는 테스트 대역은 스텁이다.

**모든 제품 코드는 2차원으로 분류할 수 있다.**

- 공개 API또는 비공개 API
- 식별할 수 있는 동작 또는 구현 세부 사항
    
    각 차원의 범주는 겹치지 않는다
    

식별 할 수 있는 동작과 구현 세부상항에는 미묘한 차이가 있다. 식벼할 수 있는 동작이라면 다음중 하나를 해야한다.

- 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출 -> 연산은 계산을 수행하거나 부작용을 가져오거나 둘다하는 메서드이다.
- 클라이언트가 목표를 달성하는데 도움이 된느 상태를 노출

구현 세부 사항은 위의 두개중 그 어느 것도 하지 않는다.

이상적으로 시스템 공개 API는 식별할 수 있는 동작과 일치해야 하고 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야한다.

```
s tring normalizedName = user.NormalizeName(newName); user.Name = normalizedName;

리팩터링 후-> user.Name = newName;
```

**잘 설계된 API 캡슐화**

캡슐화는 분변성 위반이라고도 하는 모순을 방지하는 조치이다.

- 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

### 목과 테스트 취약성 관계

### 육각형 아키텍쳐

어플리케이션 서비스 계층은 도메인 계층위에 있으며 외부 환경과의 통신을 조정한다.

어플리케이션 서비스에 대한 조정의 예이다.

- 데이터 베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
- 해당 인스턴스에 연산 호출
- 결과를 데이터베이스에 다시 저장

어플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형상하고 다른 어플리케이션과 소통할 수 있다.

육각형 아키텍처의 주 목적은 다음과 같다.

- 도메인 계층과 어플리케이션 서비스 계층 간의 관심사 분리
- 어플리케이션 내부 통신
- 어플리케이션 간의 통신

각 계층의 API를 잘 설계하면 테스트도 프랙탈 구조를 갖기 시작한다.

### 시스템 내부 통신과 시스템 간 통신

연산을 수행하기위한 도메인 클래스간 협력은 식별할 수 있는 동작이 아니기에 시스템 내부 통신은 구현 세부 사항에 해당한다. 이러한 협력은 클라이언트 목표와 직접적인 관계가 없기에 테스트가 취약해질 수 있다.